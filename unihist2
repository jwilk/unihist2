#!/usr/bin/env python3
# encoding=UTF-8

# Copyright Â© 2021 Jakub Wilk <jwilk@jwilk.net>
# SPDX-License-Identifier: MIT

import argparse
import collections
import signal
import sys
import unicodedata

0_0  # Python >= 3.6 is required

chunk_size = 64 * 1024

def read_file_basic(data, file):
    while True:
        chunk = file.read(chunk_size)
        if not chunk:
            break
        for ch in chunk:
            data[ch] += 1

def read_file_egc(data, file):
    import regex
    tail = ''
    while True:
        chunk = file.read(chunk_size)
        chars = regex.findall(r'\X', tail + chunk)
        tail = chars.pop() if chars else ''
        for clt in chars:
            data[clt] += 1
        if not chunk:
            break
    if tail:
        data[tail] += 1

def get_char_name(ch, cat):
    name = unicodedata.name(ch, '')
    if name:
        return name
    if cat == 'Cn':
        return 'non-character'
    elif cat == 'Cc':
        # TODO: elaborate
        return 'control character'
    elif cat == 'Cs':
        return 'lone surrogate'
    return ''

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('-G', dest='egc', action='store_true',
        help='use Extended Grapheme Clusters'
    )
    ap.add_argument('paths', metavar='FILE', nargs='*',
        help='file to analyze (default: stdin)'
    )
    options = ap.parse_args()
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)
    data = collections.Counter()
    read_file = [read_file_basic, read_file_egc][options.egc]
    for path in options.paths or ['-']:
        if path == '-':
            read_file(data, sys.stdin)
        else:
            with open(path, 'rt') as file:
                read_file(data, file)
    for clt, count in sorted(data.items()):
        glyph = clt
        display_pts = []
        display_names = []
        for i, ch in enumerate(clt):
            pt = ord(ch)
            cat = unicodedata.category(ch)
            name = get_char_name(ch, cat)
            if not name and len(clt) > 1:
                name = '?'
            display_pts += [f'U+{pt:04X}']
            display_names += [name]
            if i == 0 and cat[0] == 'C':
                glyph = ''
            elif i == 0 and cat[0] == 'M':
                glyph = '\N{DOTTED CIRCLE}' + clt
        display_pts = ' '.join(display_pts)
        display_names = ' + '.join(display_names)
        print(f'{count}\t{glyph}\t{display_pts}\t{display_names}')

if __name__ == '__main__':
    main()

# vim:ts=4 sts=4 sw=4 et
