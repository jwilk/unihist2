#!/usr/bin/env python3
# encoding=UTF-8

# Copyright © 2021-2024 Jakub Wilk <jwilk@jwilk.net>
# SPDX-License-Identifier: MIT

import argparse
import collections
import signal
import sys
import unicodedata

async def _(): f'{await "# Python >= 3.7 is required #"}'

chunk_size = 64 * 1024

def read_file_basic(data, file):
    if file.isatty():
        read = file.readline
    else:
        read = file.read
    while True:
        chunk = read(chunk_size)
        if not chunk:
            break
        for ch in chunk:
            data[ch] += 1

def read_file_egc(data, file):
    # Python stdlib doesn't support grapheme clustering yet:
    # https://github.com/python/cpython/issues/74902
    # Use third-party library in the mean time.
    import regex
    tail = ''
    if file.isatty():
        read = file.readline
    else:
        read = file.read
    while True:
        chunk = read(chunk_size)
        chars = regex.findall(r'\X', tail + chunk)
        tail = chars.pop() if chars else ''
        for clt in chars:
            data[clt] += 1
        if not chunk:
            break
    if tail:
        data[tail] += 1

_cc_names = {
# Generated by private/gen-cc-names:
    '\x00': 'NULL',
    '\x01': 'START OF HEADING',
    '\x02': 'START OF TEXT',
    '\x03': 'END OF TEXT',
    '\x04': 'END OF TRANSMISSION',
    '\x05': 'ENQUIRY',
    '\x06': 'ACKNOWLEDGE',
    '\x07': 'ALERT',
    '\x08': 'BACKSPACE',
    '\x09': 'CHARACTER TABULATION',
    '\x0A': 'LINE FEED',
    '\x0B': 'LINE TABULATION',
    '\x0C': 'FORM FEED',
    '\x0D': 'CARRIAGE RETURN',
    '\x0E': 'SHIFT OUT',
    '\x0F': 'SHIFT IN',
    '\x10': 'DATA LINK ESCAPE',
    '\x11': 'DEVICE CONTROL ONE',
    '\x12': 'DEVICE CONTROL TWO',
    '\x13': 'DEVICE CONTROL THREE',
    '\x14': 'DEVICE CONTROL FOUR',
    '\x15': 'NEGATIVE ACKNOWLEDGE',
    '\x16': 'SYNCHRONOUS IDLE',
    '\x17': 'END OF TRANSMISSION BLOCK',
    '\x18': 'CANCEL',
    '\x19': 'END OF MEDIUM',
    '\x1A': 'SUBSTITUTE',
    '\x1B': 'ESCAPE',
    '\x1C': 'INFORMATION SEPARATOR FOUR',
    '\x1D': 'INFORMATION SEPARATOR THREE',
    '\x1E': 'INFORMATION SEPARATOR TWO',
    '\x1F': 'INFORMATION SEPARATOR ONE',
    '\x7F': 'DELETE',
    '\x80': 'PADDING CHARACTER',
    '\x81': 'HIGH OCTET PRESET',
    '\x82': 'BREAK PERMITTED HERE',
    '\x83': 'NO BREAK HERE',
    '\x84': 'INDEX',
    '\x85': 'NEXT LINE',
    '\x86': 'START OF SELECTED AREA',
    '\x87': 'END OF SELECTED AREA',
    '\x88': 'CHARACTER TABULATION SET',
    '\x89': 'CHARACTER TABULATION WITH JUSTIFICATION',
    '\x8A': 'LINE TABULATION SET',
    '\x8B': 'PARTIAL LINE FORWARD',
    '\x8C': 'PARTIAL LINE BACKWARD',
    '\x8D': 'REVERSE LINE FEED',
    '\x8E': 'SINGLE SHIFT TWO',
    '\x8F': 'SINGLE SHIFT THREE',
    '\x90': 'DEVICE CONTROL STRING',
    '\x91': 'PRIVATE USE ONE',
    '\x92': 'PRIVATE USE TWO',
    '\x93': 'SET TRANSMIT STATE',
    '\x94': 'CANCEL CHARACTER',
    '\x95': 'MESSAGE WAITING',
    '\x96': 'START OF GUARDED AREA',
    '\x97': 'END OF GUARDED AREA',
    '\x98': 'START OF STRING',
    '\x99': 'SINGLE GRAPHIC CHARACTER INTRODUCER',
    '\x9A': 'SINGLE CHARACTER INTRODUCER',
    '\x9B': 'CONTROL SEQUENCE INTRODUCER',
    '\x9C': 'STRING TERMINATOR',
    '\x9D': 'OPERATING SYSTEM COMMAND',
    '\x9E': 'PRIVACY MESSAGE',
    '\x9F': 'APPLICATION PROGRAM COMMAND',
}

def get_char_name(ch):
    name = unicodedata.name(ch, None)
    cat = unicodedata.category(ch)
    if name:
        return name
    if cat == 'Cc':
        name = _cc_names.get(ch)
        if name:
            pt = ord(ch)
            try:
                assert unicodedata.lookup(name) == ch, f'{name} != U+{pt:04X}'
            except KeyError:
                assert False, f'{name} != U+{pt:04X}'
            return name
        return 'control character'
    # use code point label as fallback
    # (see The Unicode Standard version 15.0, §4.8)
    label_prefix = dict(
        Cc='control',
        Cn='reserved',
        Co='private-use',
        Cs='surrogate',
    ).get(cat)
    pt = ord(ch)
    if pt & 0xFFFF >= 0xFFFE or 0xFDD0 <= pt < 0xFDF0:
        assert label_prefix == 'reserved'
        label_prefix = 'noncharacter'
    if label_prefix:
        return f'<{label_prefix}-{pt:04X}>'
    return None

def format_pts(s):
    return str.join(' ', (
        f'U+{ord(ch):04X}' for ch in s
    ))

def format_names(s):
    names = str.join(' + ', (
        get_char_name(ch) or '?'
        for ch in s
    ))
    if names == '?':
        names = ''
    return names

def format_glyph(s):
    if not s:
        return ''
    cat = unicodedata.category(s[0])
    if cat[0] == 'C':
        return ''
    if cat in {'Zl', 'Zp'}:
        return ''
    if cat[0] == 'M':
        return '\N{DOTTED CIRCLE}' + s
    return s

def main():
    ap = argparse.ArgumentParser()
    if sys.version_info < (3, 10):
        # https://bugs.python.org/issue9694
        ap._optionals.title = 'options'
    ap.add_argument('-G', dest='egc', action='store_true',
        help='use Extended Grapheme Clusters'
    )
    ap.add_argument('paths', metavar='FILE', nargs='*',
        help='file to analyze (default: stdin)'
    )
    ap.add_argument('--traceback', action='store_true', help=argparse.SUPPRESS)
    options = ap.parse_args()
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)
    data = collections.Counter()
    read_file = [read_file_basic, read_file_egc][options.egc]
    enc_errors = sys.stdin.errors
    open_kw = dict(
        encoding=sys.stdin.encoding,
        errors=enc_errors,
        newline=''
    )
    if enc_errors in {'strict', 'surrogateescape'}:
        open_kw.update(errors='surrogatepass')
        sys.stdin.reconfigure(**open_kw)
    for path in options.paths or ['-']:
        if path == '-':
            read_file(data, sys.stdin)
        else:
            try:
                file = open(path, 'rt', **open_kw)
            except OSError as exc:
                if options.traceback:
                    raise
                msg = f'{ap.prog}: {path}: {exc.strerror}'
                print(msg, file=sys.stderr)
                sys.exit(1)
            with file:
                read_file(data, file)
    for clt, count in sorted(data.items()):
        glyph = format_glyph(clt)
        pts = format_pts(clt)
        names = format_names(clt)
        print(count, glyph, pts, names, sep='\t')

if __name__ == '__main__':
    main()

# vim:ts=4 sts=4 sw=4 et
