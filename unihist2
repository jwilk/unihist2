#!/usr/bin/env python3
# encoding=UTF-8

# Copyright © 2021-2023 Jakub Wilk <jwilk@jwilk.net>
# SPDX-License-Identifier: MIT

import argparse
import collections
import io
import signal
import sys
import unicodedata

type(0_0)  # Python >= 3.6 is required

chunk_size = 64 * 1024

def read_file_basic(data, file):
    if file.isatty():
        read = file.readline
    else:
        read = file.read
    while True:
        chunk = read(chunk_size)
        if not chunk:
            break
        for ch in chunk:
            data[ch] += 1

def read_file_egc(data, file):
    # Python stdlib doesn't support grapheme clustering yet:
    # https://github.com/python/cpython/issues/74902
    # Use third-party library in the mean time.
    import regex
    tail = ''
    if file.isatty():
        read = file.readline
    else:
        read = file.read
    while True:
        chunk = read(chunk_size)
        chars = regex.findall(r'\X', tail + chunk)
        tail = chars.pop() if chars else ''
        for clt in chars:
            data[clt] += 1
        if not chunk:
            break
    if tail:
        data[tail] += 1

_cc_names = {
# Generated by:
# perl -an -F';' -E '$F[2] eq "Cc" and $F[10] and do { $_ = $F[10]; s/ [(].*//; s/^BELL$/ALERT/; say "    \x27\x5Cu$F[0]\x27: \x27$_\x27," }' < /usr/share/unicode/UnicodeData.txt
    '\u0000': 'NULL',
    '\u0001': 'START OF HEADING',
    '\u0002': 'START OF TEXT',
    '\u0003': 'END OF TEXT',
    '\u0004': 'END OF TRANSMISSION',
    '\u0005': 'ENQUIRY',
    '\u0006': 'ACKNOWLEDGE',
    '\u0007': 'ALERT',
    '\u0008': 'BACKSPACE',
    '\u0009': 'CHARACTER TABULATION',
    '\u000A': 'LINE FEED',
    '\u000B': 'LINE TABULATION',
    '\u000C': 'FORM FEED',
    '\u000D': 'CARRIAGE RETURN',
    '\u000E': 'SHIFT OUT',
    '\u000F': 'SHIFT IN',
    '\u0010': 'DATA LINK ESCAPE',
    '\u0011': 'DEVICE CONTROL ONE',
    '\u0012': 'DEVICE CONTROL TWO',
    '\u0013': 'DEVICE CONTROL THREE',
    '\u0014': 'DEVICE CONTROL FOUR',
    '\u0015': 'NEGATIVE ACKNOWLEDGE',
    '\u0016': 'SYNCHRONOUS IDLE',
    '\u0017': 'END OF TRANSMISSION BLOCK',
    '\u0018': 'CANCEL',
    '\u0019': 'END OF MEDIUM',
    '\u001A': 'SUBSTITUTE',
    '\u001B': 'ESCAPE',
    '\u001C': 'INFORMATION SEPARATOR FOUR',
    '\u001D': 'INFORMATION SEPARATOR THREE',
    '\u001E': 'INFORMATION SEPARATOR TWO',
    '\u001F': 'INFORMATION SEPARATOR ONE',
    '\u007F': 'DELETE',
    '\u0082': 'BREAK PERMITTED HERE',
    '\u0083': 'NO BREAK HERE',
    '\u0085': 'NEXT LINE',
    '\u0086': 'START OF SELECTED AREA',
    '\u0087': 'END OF SELECTED AREA',
    '\u0088': 'CHARACTER TABULATION SET',
    '\u0089': 'CHARACTER TABULATION WITH JUSTIFICATION',
    '\u008A': 'LINE TABULATION SET',
    '\u008B': 'PARTIAL LINE FORWARD',
    '\u008C': 'PARTIAL LINE BACKWARD',
    '\u008D': 'REVERSE LINE FEED',
    '\u008E': 'SINGLE SHIFT TWO',
    '\u008F': 'SINGLE SHIFT THREE',
    '\u0090': 'DEVICE CONTROL STRING',
    '\u0091': 'PRIVATE USE ONE',
    '\u0092': 'PRIVATE USE TWO',
    '\u0093': 'SET TRANSMIT STATE',
    '\u0094': 'CANCEL CHARACTER',
    '\u0095': 'MESSAGE WAITING',
    '\u0096': 'START OF GUARDED AREA',
    '\u0097': 'END OF GUARDED AREA',
    '\u0098': 'START OF STRING',
    '\u009A': 'SINGLE CHARACTER INTRODUCER',
    '\u009B': 'CONTROL SEQUENCE INTRODUCER',
    '\u009C': 'STRING TERMINATOR',
    '\u009D': 'OPERATING SYSTEM COMMAND',
    '\u009E': 'PRIVACY MESSAGE',
    '\u009F': 'APPLICATION PROGRAM COMMAND',
}

def get_char_name(ch):
    name = unicodedata.name(ch, None)
    cat = unicodedata.category(ch)
    if name:
        return name
    if cat == 'Cc':
        name = _cc_names.get(ch)
        if name:
            pt = ord(ch)
            try:
                assert unicodedata.lookup(name) == ch, f'{name} != U+{pt:04X}'
            except KeyError:
                assert False, f'{name} != U+{pt:04X}'
            return name
        return 'control character'
    # use code point label as fallback
    # (see The Unicode Standard version 13.0, §4.8)
    label_prefix = dict(
        Cc='control',
        Cn='reserved',
        Co='private-use',
        Cs='surrogate',
    ).get(cat)
    pt = ord(ch)
    if pt & 0xFFFF >= 0xFFFE or 0xFDD0 <= pt < 0xFDF0:
        assert label_prefix == 'reserved'
        label_prefix = 'noncharacter'
    if label_prefix:
        return f'<{label_prefix}-{pt:04X}>'
    return None

def format_pts(s):
    return str.join(' ', (
        f'U+{ord(ch):04X}' for ch in s
    ))

def format_names(s):
    names = str.join(' + ', (
        get_char_name(ch) or '?'
        for ch in s
    ))
    if names == '?':
        names = ''
    return names

def format_glyph(s):
    if not s:
        return ''
    cat = unicodedata.category(s[0])
    if cat[0] in 'C':
        return ''
    if cat in {'Zl', 'Zp'}:
        return ''
    if cat[0] == 'M':
        return '\N{DOTTED CIRCLE}' + s
    return s

def main():
    ap = argparse.ArgumentParser()
    if sys.version_info < (3, 10):
        # https://bugs.python.org/issue9694
        ap._optionals.title = 'options'
    ap.add_argument('-G', dest='egc', action='store_true',
        help='use Extended Grapheme Clusters'
    )
    ap.add_argument('paths', metavar='FILE', nargs='*',
        help='file to analyze (default: stdin)'
    )
    options = ap.parse_args()
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)
    data = collections.Counter()
    read_file = [read_file_basic, read_file_egc][options.egc]
    enc_errors = sys.stdin.errors
    open_kw = dict(
        encoding=sys.stdin.encoding,
        errors=enc_errors,
        newline=''
    )
    if enc_errors in {'strict', 'surrogateescape'}:
        open_kw.update(errors='surrogatepass')
        if sys.version_info >= (3, 7):
            sys.stdin.reconfigure(**open_kw)
        else:
            sys.stdin = io.TextIOWrapper(sys.stdin.buffer, **open_kw)
    for path in options.paths or ['-']:
        if path == '-':
            read_file(data, sys.stdin)
        else:
            with open(path, 'rt', **open_kw) as file:
                read_file(data, file)
    for clt, count in sorted(data.items()):
        glyph = format_glyph(clt)
        pts = format_pts(clt)
        names = format_names(clt)
        print(f'{count}\t{glyph}\t{pts}\t{names}')

if __name__ == '__main__':
    main()

# vim:ts=4 sts=4 sw=4 et
